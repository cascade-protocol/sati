/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from "@solana/kit";
import { SATI_PROGRAM_ADDRESS } from "../programs";
import { getAccountMetaFactory, type ResolvedAccount } from "../shared";

export const CLOSE_REGULAR_ATTESTATION_DISCRIMINATOR = new Uint8Array([
  243, 10, 146, 163, 169, 75, 64, 28,
]);

export function getCloseRegularAttestationDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CLOSE_REGULAR_ATTESTATION_DISCRIMINATOR,
  );
}

export type CloseRegularAttestationInstruction<
  TProgram extends string = typeof SATI_PROGRAM_ADDRESS,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountSigner extends string | AccountMeta<string> = string,
  TAccountSchemaConfig extends string | AccountMeta<string> = string,
  TAccountSatiPda extends string | AccountMeta<string> = string,
  TAccountSatiCredential extends string | AccountMeta<string> = string,
  TAccountAttestation extends string | AccountMeta<string> = string,
  TAccountSasProgram extends string | AccountMeta<string> =
    "22zoJMtdu4tQc2PzL74ZUT7FrwgB1Udec8DdW4yw4BdG",
  TAccountAgentAta extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends string | AccountMeta<string> = string,
  TAccountEventAuthority extends string | AccountMeta<string> = string,
  TAccountProgram extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountSigner extends string
        ? ReadonlySignerAccount<TAccountSigner> &
            AccountSignerMeta<TAccountSigner>
        : TAccountSigner,
      TAccountSchemaConfig extends string
        ? ReadonlyAccount<TAccountSchemaConfig>
        : TAccountSchemaConfig,
      TAccountSatiPda extends string
        ? ReadonlyAccount<TAccountSatiPda>
        : TAccountSatiPda,
      TAccountSatiCredential extends string
        ? ReadonlyAccount<TAccountSatiCredential>
        : TAccountSatiCredential,
      TAccountAttestation extends string
        ? WritableAccount<TAccountAttestation>
        : TAccountAttestation,
      TAccountSasProgram extends string
        ? ReadonlyAccount<TAccountSasProgram>
        : TAccountSasProgram,
      TAccountAgentAta extends string
        ? ReadonlyAccount<TAccountAgentAta>
        : TAccountAgentAta,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >;

export type CloseRegularAttestationInstructionData = {
  discriminator: ReadonlyUint8Array;
};

export type CloseRegularAttestationInstructionDataArgs = {};

export function getCloseRegularAttestationInstructionDataEncoder(): FixedSizeEncoder<CloseRegularAttestationInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({
      ...value,
      discriminator: CLOSE_REGULAR_ATTESTATION_DISCRIMINATOR,
    }),
  );
}

export function getCloseRegularAttestationInstructionDataDecoder(): FixedSizeDecoder<CloseRegularAttestationInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getCloseRegularAttestationInstructionDataCodec(): FixedSizeCodec<
  CloseRegularAttestationInstructionDataArgs,
  CloseRegularAttestationInstructionData
> {
  return combineCodec(
    getCloseRegularAttestationInstructionDataEncoder(),
    getCloseRegularAttestationInstructionDataDecoder(),
  );
}

export type CloseRegularAttestationAsyncInput<
  TAccountPayer extends string = string,
  TAccountSigner extends string = string,
  TAccountSchemaConfig extends string = string,
  TAccountSatiPda extends string = string,
  TAccountSatiCredential extends string = string,
  TAccountAttestation extends string = string,
  TAccountSasProgram extends string = string,
  TAccountAgentAta extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  /** Payer receives rent back */
  payer: TransactionSigner<TAccountPayer>;
  /** Signer must be either the agent (NFT owner via ATA) or the counterparty */
  signer: TransactionSigner<TAccountSigner>;
  /** Schema config PDA */
  schemaConfig: Address<TAccountSchemaConfig>;
  /** SATI Attestation Program PDA - authorized signer on SAS credential */
  satiPda?: Address<TAccountSatiPda>;
  /** SATI SAS credential account */
  satiCredential: Address<TAccountSatiCredential>;
  /** Attestation account to be closed */
  attestation: Address<TAccountAttestation>;
  /** SAS program */
  sasProgram?: Address<TAccountSasProgram>;
  /**
   * Optional: Agent's ATA (required if signer is NFT owner, not counterparty).
   * If provided, must hold the agent NFT (mint matches token_account from data).
   * Note: token_account in data is the MINT address; this is the holder's ATA.
   */
  agentAta?: Address<TAccountAgentAta>;
  /** Token-2022 program for ATA verification (optional, required with agent_ata) */
  tokenProgram?: Address<TAccountTokenProgram>;
  eventAuthority?: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
};

export async function getCloseRegularAttestationInstructionAsync<
  TAccountPayer extends string,
  TAccountSigner extends string,
  TAccountSchemaConfig extends string,
  TAccountSatiPda extends string,
  TAccountSatiCredential extends string,
  TAccountAttestation extends string,
  TAccountSasProgram extends string,
  TAccountAgentAta extends string,
  TAccountTokenProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof SATI_PROGRAM_ADDRESS,
>(
  input: CloseRegularAttestationAsyncInput<
    TAccountPayer,
    TAccountSigner,
    TAccountSchemaConfig,
    TAccountSatiPda,
    TAccountSatiCredential,
    TAccountAttestation,
    TAccountSasProgram,
    TAccountAgentAta,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress },
): Promise<
  CloseRegularAttestationInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountSigner,
    TAccountSchemaConfig,
    TAccountSatiPda,
    TAccountSatiCredential,
    TAccountAttestation,
    TAccountSasProgram,
    TAccountAgentAta,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? SATI_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: false },
    schemaConfig: { value: input.schemaConfig ?? null, isWritable: false },
    satiPda: { value: input.satiPda ?? null, isWritable: false },
    satiCredential: { value: input.satiCredential ?? null, isWritable: false },
    attestation: { value: input.attestation ?? null, isWritable: true },
    sasProgram: { value: input.sasProgram ?? null, isWritable: false },
    agentAta: { value: input.agentAta ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.satiPda.value) {
    accounts.satiPda.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            115, 97, 116, 105, 95, 97, 116, 116, 101, 115, 116, 97, 116, 105,
            111, 110,
          ]),
        ),
      ],
    });
  }
  if (!accounts.sasProgram.value) {
    accounts.sasProgram.value =
      "22zoJMtdu4tQc2PzL74ZUT7FrwgB1Udec8DdW4yw4BdG" as Address<"22zoJMtdu4tQc2PzL74ZUT7FrwgB1Udec8DdW4yw4BdG">;
  }
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111, 114,
            105, 116, 121,
          ]),
        ),
      ],
    });
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.signer),
      getAccountMeta(accounts.schemaConfig),
      getAccountMeta(accounts.satiPda),
      getAccountMeta(accounts.satiCredential),
      getAccountMeta(accounts.attestation),
      getAccountMeta(accounts.sasProgram),
      getAccountMeta(accounts.agentAta),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getCloseRegularAttestationInstructionDataEncoder().encode({}),
    programAddress,
  } as CloseRegularAttestationInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountSigner,
    TAccountSchemaConfig,
    TAccountSatiPda,
    TAccountSatiCredential,
    TAccountAttestation,
    TAccountSasProgram,
    TAccountAgentAta,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export type CloseRegularAttestationInput<
  TAccountPayer extends string = string,
  TAccountSigner extends string = string,
  TAccountSchemaConfig extends string = string,
  TAccountSatiPda extends string = string,
  TAccountSatiCredential extends string = string,
  TAccountAttestation extends string = string,
  TAccountSasProgram extends string = string,
  TAccountAgentAta extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  /** Payer receives rent back */
  payer: TransactionSigner<TAccountPayer>;
  /** Signer must be either the agent (NFT owner via ATA) or the counterparty */
  signer: TransactionSigner<TAccountSigner>;
  /** Schema config PDA */
  schemaConfig: Address<TAccountSchemaConfig>;
  /** SATI Attestation Program PDA - authorized signer on SAS credential */
  satiPda: Address<TAccountSatiPda>;
  /** SATI SAS credential account */
  satiCredential: Address<TAccountSatiCredential>;
  /** Attestation account to be closed */
  attestation: Address<TAccountAttestation>;
  /** SAS program */
  sasProgram?: Address<TAccountSasProgram>;
  /**
   * Optional: Agent's ATA (required if signer is NFT owner, not counterparty).
   * If provided, must hold the agent NFT (mint matches token_account from data).
   * Note: token_account in data is the MINT address; this is the holder's ATA.
   */
  agentAta?: Address<TAccountAgentAta>;
  /** Token-2022 program for ATA verification (optional, required with agent_ata) */
  tokenProgram?: Address<TAccountTokenProgram>;
  eventAuthority: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
};

export function getCloseRegularAttestationInstruction<
  TAccountPayer extends string,
  TAccountSigner extends string,
  TAccountSchemaConfig extends string,
  TAccountSatiPda extends string,
  TAccountSatiCredential extends string,
  TAccountAttestation extends string,
  TAccountSasProgram extends string,
  TAccountAgentAta extends string,
  TAccountTokenProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof SATI_PROGRAM_ADDRESS,
>(
  input: CloseRegularAttestationInput<
    TAccountPayer,
    TAccountSigner,
    TAccountSchemaConfig,
    TAccountSatiPda,
    TAccountSatiCredential,
    TAccountAttestation,
    TAccountSasProgram,
    TAccountAgentAta,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress },
): CloseRegularAttestationInstruction<
  TProgramAddress,
  TAccountPayer,
  TAccountSigner,
  TAccountSchemaConfig,
  TAccountSatiPda,
  TAccountSatiCredential,
  TAccountAttestation,
  TAccountSasProgram,
  TAccountAgentAta,
  TAccountTokenProgram,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? SATI_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: false },
    schemaConfig: { value: input.schemaConfig ?? null, isWritable: false },
    satiPda: { value: input.satiPda ?? null, isWritable: false },
    satiCredential: { value: input.satiCredential ?? null, isWritable: false },
    attestation: { value: input.attestation ?? null, isWritable: true },
    sasProgram: { value: input.sasProgram ?? null, isWritable: false },
    agentAta: { value: input.agentAta ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.sasProgram.value) {
    accounts.sasProgram.value =
      "22zoJMtdu4tQc2PzL74ZUT7FrwgB1Udec8DdW4yw4BdG" as Address<"22zoJMtdu4tQc2PzL74ZUT7FrwgB1Udec8DdW4yw4BdG">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.signer),
      getAccountMeta(accounts.schemaConfig),
      getAccountMeta(accounts.satiPda),
      getAccountMeta(accounts.satiCredential),
      getAccountMeta(accounts.attestation),
      getAccountMeta(accounts.sasProgram),
      getAccountMeta(accounts.agentAta),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getCloseRegularAttestationInstructionDataEncoder().encode({}),
    programAddress,
  } as CloseRegularAttestationInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountSigner,
    TAccountSchemaConfig,
    TAccountSatiPda,
    TAccountSatiCredential,
    TAccountAttestation,
    TAccountSasProgram,
    TAccountAgentAta,
    TAccountTokenProgram,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export type ParsedCloseRegularAttestationInstruction<
  TProgram extends string = typeof SATI_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Payer receives rent back */
    payer: TAccountMetas[0];
    /** Signer must be either the agent (NFT owner via ATA) or the counterparty */
    signer: TAccountMetas[1];
    /** Schema config PDA */
    schemaConfig: TAccountMetas[2];
    /** SATI Attestation Program PDA - authorized signer on SAS credential */
    satiPda: TAccountMetas[3];
    /** SATI SAS credential account */
    satiCredential: TAccountMetas[4];
    /** Attestation account to be closed */
    attestation: TAccountMetas[5];
    /** SAS program */
    sasProgram: TAccountMetas[6];
    /**
     * Optional: Agent's ATA (required if signer is NFT owner, not counterparty).
     * If provided, must hold the agent NFT (mint matches token_account from data).
     * Note: token_account in data is the MINT address; this is the holder's ATA.
     */
    agentAta?: TAccountMetas[7] | undefined;
    /** Token-2022 program for ATA verification (optional, required with agent_ata) */
    tokenProgram?: TAccountMetas[8] | undefined;
    eventAuthority: TAccountMetas[9];
    program: TAccountMetas[10];
  };
  data: CloseRegularAttestationInstructionData;
};

export function parseCloseRegularAttestationInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedCloseRegularAttestationInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === SATI_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      signer: getNextAccount(),
      schemaConfig: getNextAccount(),
      satiPda: getNextAccount(),
      satiCredential: getNextAccount(),
      attestation: getNextAccount(),
      sasProgram: getNextAccount(),
      agentAta: getNextOptionalAccount(),
      tokenProgram: getNextOptionalAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getCloseRegularAttestationInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
